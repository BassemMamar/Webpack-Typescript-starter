{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/app/ads-state.ts","webpack:///./src/app/config.ts","webpack:///./src/app/helper.ts","webpack:///./src/app/ads-video-handler.ts","webpack:///./src/app/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","AdsState","DefaultConfig","fraction","continuousTime","autoplay","getX","element","elementX","offsetLeft","elementParentX","parentElement","getY","elementY","offsetTop","elementParentY","AdsVideoHandler","videoId","config","this","video","document","getElementById","Error","init","state","Ready","continuesPlayingTimerReference","window","addEventListener","adsVisiblityChangingHandler","_this","isAdsVideoVisible","Finished","Started","PlayAdsVideo","then","console","log","ontimeupdate","ontimeupdateEventHandler","onended","onendedEventHandler","continuesPlayingTimeMonator","catch","error","Paused","pause","cancelMonatorTimer","Promise","resolve","undefined","playPromise","play","x","y","elementWidth","offsetWidth","elementHeight","offsetHeight","b","Math","max","min","pageXOffset","innerWidth","pageYOffset","innerHeight","isElementVisible","currentPercentage","currentTime","duration","checkTimeProgressPercentageChanges","Passed75","Passed50","Passed25","setTimeout","clearTimeout","ads_video_handler"],"mappings":"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","file":"js/library.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export enum AdsState {\r\n    Ready = 0,\r\n    Paused = 1,\r\n    Started = 2,\r\n    Passed25 = 3,\r\n    Passed50 = 4,\r\n    Passed75 = 5,\r\n    Finished = 6,\r\n}\r\n","interface AdsVideoConfig {\r\n    fraction: number;\r\n    continuousTime: number;\r\n    autoplay: boolean;\r\n}\r\n\r\nconst DefaultConfig = {\r\n    fraction: 0.5,\r\n    continuousTime: 2,\r\n    autoplay: false\r\n}\r\n\r\nexport { AdsVideoConfig, DefaultConfig };","import { DefaultConfig } from \"./config\";\r\n\r\n/**\r\n * An equivalent is being applied to determine weither the html element is \r\n * visible in the viewport or not.\r\n * First we calculate visiblity in both X and Y Axes\r\n * then calculate the total visiblity by divide the avilable space of the element \r\n * on the full space of the element and compare the result with the fraction ratio.\r\n * check here for more information\r\n * https://stackoverflow.com/a/22831887/3635406\r\n * \r\n * @param element Html element to check it's viewport acourding to the browser\r\n * @param fraction Percentage of the element to be visible in the viewport\r\n */\r\nlet isElementVisible = (element: HTMLElement, fraction: number = DefaultConfig.fraction): boolean => {\r\n    let x = getX(element),\r\n        y = getY(element),\r\n        elementWidth = element.offsetWidth,\r\n        elementHeight = element.offsetHeight,\r\n        r = x + elementWidth, //right\r\n        b = y + elementHeight, //bottom\r\n        visibleX, visibleY, visible;\r\n\r\n    visibleX = Math.max(0, Math.min(elementWidth, window.pageXOffset + window.innerWidth - x, r - window.pageXOffset));\r\n    visibleY = Math.max(0, Math.min(elementHeight, window.pageYOffset + window.innerHeight - y, b - window.pageYOffset));\r\n    visible = visibleX * visibleY / (elementWidth * elementHeight);\r\n    \r\n    return visible >= fraction;\r\n}\r\n\r\n/**\r\n * recurtion funtion to sum element offsetLeft with it's parents values \r\n * @param element  Html element to calculate it's offsetLeft\r\n */\r\nlet getX = (element: HTMLElement) => {\r\n    if (element == null)\r\n        return 0;\r\n\r\n    let elementX = element.offsetLeft;\r\n    if (elementX === 0) {\r\n        return 0;\r\n    }\r\n    \r\n    let elementParentX = element.parentElement ? element.parentElement.offsetLeft : 0;\r\n    if (elementX !== elementParentX) {\r\n        return elementX + getX(element.parentElement);\r\n    }\r\n\r\n    if (elementX === elementParentX) {\r\n        return getX(element.parentElement);\r\n    }\r\n}\r\n\r\n/**\r\n * recurtion funtion to sum element offsetTop with it's parents values \r\n * @param element  Html element to calculate it's offsetTop\r\n */\r\nlet getY = (element: HTMLElement) => {\r\n    if (element == null)\r\n        return 0;\r\n\r\n    let elementY = element.offsetTop;\r\n    if (elementY === 0) {\r\n        return 0;\r\n    }\r\n    let elementParentY = element.parentElement ? element.parentElement.offsetTop : 0;\r\n    if (elementY !== elementParentY) {\r\n        return elementY + getY(element.parentElement);\r\n    }\r\n\r\n    if (elementY === elementParentY) {\r\n        return getY(element.parentElement);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * The Key Point: Don't ever assume a video will play. * \r\n * this method encapsolate partially promise returned when play a video in different browsers\r\n * so that the caller just assume it always return a promise\r\n * for more information chenk the links below:\r\n * https://developers.google.com/web/updates/2017/09/autoplay-policy-changes\r\n * https://developers.google.com/web/updates/2016/03/play-returns-promise\r\n * \r\n * @param video The video element reference\r\n */\r\nlet videoPlayingHandler = (video: HTMLVideoElement): Promise<void> => {\r\n    let playPromise = video.play();\r\n\r\n    // In browsers that don’t yet support this functionality,\r\n    // playPromise won’t be defined.\r\n    if (playPromise !== undefined) {\r\n        return playPromise;\r\n    }\r\n    else {\r\n        return Promise.resolve();\r\n    }\r\n}\r\n\r\nexport { isElementVisible, videoPlayingHandler }","import { AdsState } from \"./ads-state\";\r\nimport { isElementVisible, videoPlayingHandler } from \"./helper\";\r\nimport { AdsVideoConfig, DefaultConfig } from \"./config\";\r\n\r\nexport default class AdsVideoHandler {\r\n\r\n  /**\r\n   * The ads video element reference\r\n   */\r\n  video: HTMLVideoElement;\r\n\r\n  /**\r\n   * The ads video state during it's lifecycle\r\n   * The value can be \r\n   * Ready, Paused, Started, Passed25, Passed50, Passed75 and Finished \r\n   */\r\n  state: AdsState;\r\n\r\n  /**\r\n   * The reference for the continuous time recording timer\r\n   * required to be able to clear timer registeration if the ads video paused \r\n   * before the continues time finished\r\n   */\r\n  continuesPlayingTimerReference: any;\r\n\r\n  /**\r\n   * The total continues time for the ads video to keep playing\r\n   * so that we get notified after it finish.\r\n   * Measured as second\r\n   */\r\n  continuousTime: number;\r\n\r\n  /**\r\n   * The percentage of the ads video in the viewport of the browser to be activated\r\n   * value is a number between 0 and 1\r\n   */\r\n  fraction: number;\r\n\r\n  constructor(private videoId: string, config: AdsVideoConfig = DefaultConfig) {\r\n    this.video = <HTMLVideoElement>document.getElementById(videoId);\r\n    if (this.video == null) {\r\n      throw new Error(`Can't find video element with id ${videoId}.`);\r\n    }\r\n    this.init(config);\r\n  }\r\n\r\n  /**\r\n   * initialize properties with default value\r\n   * register window event listeners for both scroll and resize\r\n   * \r\n   * @param config The ads video config \r\n   */\r\n  init(config: AdsVideoConfig): void {\r\n    // the default state for the ads video is ready\r\n    this.state = AdsState.Ready;\r\n    this.continuesPlayingTimerReference = null;\r\n\r\n    this.continuousTime = config.continuousTime;\r\n    this.fraction = config.fraction;\r\n    this.video.autoplay = config.autoplay;\r\n\r\n    window.addEventListener('scroll', this.adsVisiblityChangingHandler.bind(this));\r\n    window.addEventListener('resize', this.adsVisiblityChangingHandler.bind(this));\r\n  }\r\n\r\n  /**\r\n   * This method get's fired when the window's scroll/size changes.\r\n   * Each time will check if ads video become visible \r\n   * in the viewport of the browser (at least 50% in our case)\r\n   * If the ads video is visible then play the ads, otherwise pause the ads.\r\n   */\r\n  adsVisiblityChangingHandler(): Promise<void> {\r\n    if (this.isAdsVideoVisible(this.video, this.fraction)) {\r\n\r\n      // state < AdsState.Started means the state either Ready or Paused\r\n      if (/** this.video.paused || */ this.state === AdsState.Finished || this.state < AdsState.Started) {\r\n\r\n        // start playing the ads video\r\n        // let playPromise = this.video.play();\r\n        return this.PlayAdsVideo(this.video).then(() => {\r\n          console.log('Video progress has been started.');\r\n\r\n          // set current ads video state to staerted\r\n          this.state = AdsState.Started;\r\n\r\n          // register ontimeupdate event handler to be able to follow the progress\r\n          this.video.ontimeupdate = this.ontimeupdateEventHandler.bind(this);\r\n\r\n          // register onended event handler to be able to know the ads viceo finished\r\n          this.video.onended = this.onendedEventHandler.bind(this);\r\n\r\n          // start monatoring the continues playing time for the ads video\r\n          this.continuesPlayingTimeMonator();\r\n\r\n        }).catch((error) => {\r\n          // Automatic playback failed.\r\n          console.error('Automatic playback failed for some reason. ', error);\r\n        });\r\n      }\r\n    }\r\n    else {\r\n      if (/** !this.video.paused */ this.state !== AdsState.Paused) {\r\n        // pause playing the ads video\r\n        this.video.pause();\r\n        this.state = AdsState.Paused;\r\n\r\n        // Cancel the timer monator in case the ads video gets paused before 2 continues seconds\r\n        this.cancelMonatorTimer();\r\n      }\r\n    }\r\n    return Promise.resolve();\r\n  }\r\n  PlayAdsVideo(video: HTMLVideoElement): any {\r\n    return videoPlayingHandler(video);\r\n  }\r\n\r\n  isAdsVideoVisible(video: HTMLVideoElement, fraction?: number): any {\r\n    return isElementVisible(video, fraction);\r\n  }\r\n\r\n  /**\r\n   * This function follow the ads video's progress and calculate the progress percentage\r\n   */\r\n  ontimeupdateEventHandler(): void {\r\n    if (this.state === AdsState.Paused) {\r\n      return;\r\n    }\r\n    // calculate passed time percentage \r\n    let currentPercentage = this.video.currentTime / this.video.duration * 100;\r\n    this.checkTimeProgressPercentageChanges(currentPercentage);\r\n  }\r\n\r\n  /**\r\n   * Update the state acourding to current progress percentage \r\n   * print to the browser console when the ads video passed 25%, 50% and 75%\r\n   * \r\n   * @param currentPercentage Value range between 0 - 100\r\n   */\r\n  checkTimeProgressPercentageChanges(currentPercentage: number) {\r\n    switch (true) {\r\n      case (currentPercentage >= 75 && currentPercentage < 100 && this.state !== AdsState.Passed75):\r\n        this.state = AdsState.Passed75;\r\n        console.log('Video progress has Passed 75%.');\r\n        break;\r\n      case (currentPercentage >= 50 && currentPercentage < 75 && this.state !== AdsState.Passed50):\r\n        this.state = AdsState.Passed50;\r\n        console.log('Video progress has Passed 50%.');\r\n        break;\r\n      case (currentPercentage >= 25 && currentPercentage < 50 && this.state !== AdsState.Passed25):\r\n        this.state = AdsState.Passed25;\r\n        console.log('Video progress has Passed 25%.');\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get fired when the ads video finish.\r\n   * print to the browser console when the ads video finish\r\n   */\r\n  onendedEventHandler(): void {\r\n    console.log('Video progress has Passed 100%.');\r\n    this.state = AdsState.Finished;\r\n  }\r\n\r\n  /**\r\n   * This function monator the continues time the ads video kept playing\r\n   * and execute a callback function which is print to the browser console in our case     \r\n   */\r\n  continuesPlayingTimeMonator(): void {\r\n    this.continuesPlayingTimerReference = setTimeout(() => {\r\n      console.log(`The ad is in the viewport of the browser for at least 50% and ${this.continuousTime} continuous seconds.`);\r\n     // this.cancelMonatorTimer();\r\n    }, this.continuousTime * 1000);\r\n  }\r\n\r\n  /**\r\n   * Cancel continues playing time monator\r\n   */\r\n  cancelMonatorTimer(): void {\r\n    clearTimeout(this.continuesPlayingTimerReference);\r\n  }\r\n}\r\n","import '../styles.scss';\r\nimport AdsVideoHandler from './ads-video-handler';\r\n\r\nwindow.addEventListener('load', () => {\r\n    console.log('document has been loaded successfully!');\r\n\r\n    /**\r\n     *  config is optional.\r\n     *  if not passed then the default configuration will applied\r\n     */\r\n    let config = {\r\n        fraction: 0.5,\r\n        continuousTime: 2,\r\n        autoplay: false\r\n    };\r\n    let handler = new AdsVideoHandler('my-ads-video', config);\r\n});"],"sourceRoot":""}